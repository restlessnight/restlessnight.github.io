<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不眠之夜の博客</title>
  
  <subtitle>不眠之夜</subtitle>
  <link href="https://blog.restlessnight.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.restlessnight.cn/"/>
  <updated>2025-04-07T08:45:53.323Z</updated>
  <id>https://blog.restlessnight.cn/</id>
  
  <author>
    <name>chenxueyao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时光错位：一次MySQL主从同步延迟的排查与优化</title>
    <link href="https://blog.restlessnight.cn/2025/04/03/shi-guang-cuo-wei-yi-ci-mysql-zhu-cong-tong-bu-yan-chi-de-pai-cha-yu-you-hua/"/>
    <id>https://blog.restlessnight.cn/2025/04/03/shi-guang-cuo-wei-yi-ci-mysql-zhu-cong-tong-bu-yan-chi-de-pai-cha-yu-you-hua/</id>
    <published>2025-04-03T09:06:53.000Z</published>
    <updated>2025-04-07T08:45:53.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时光错位：一次MySQL主从同步延迟的排查与优化"><a href="#时光错位：一次MySQL主从同步延迟的排查与优化" class="headerlink" title="时光错位：一次MySQL主从同步延迟的排查与优化"></a>时光错位：一次MySQL主从同步延迟的排查与优化</h2><h2 id="问题出现背景"><a href="#问题出现背景" class="headerlink" title="问题出现背景"></a>问题出现背景</h2><p>在生产环境中，执行 <code>ALTER TABLE</code> 语句向某张大表新增字段后，主从同步出现严重延迟。从库 <code>SHOW SLAVE STATUS</code> 显示 <code>Seconds_Behind_Master</code> 迅速增长，从正常的几秒飙升至数小时甚至上万秒，同时从库查询开始频繁超时，业务访问受阻。<code>SHOW PROCESSLIST</code> 发现大量查询处于 <code>Waiting for table metadata lock</code> 或 <code>Waiting for table flush</code> 状态，导致连接数剧增，最终触及 <code>max_connections</code> 限制，影响整个系统的稳定性。</p><h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a><strong>问题解析</strong></h2><h3 id="1-查询从库状态"><a href="#1-查询从库状态" class="headerlink" title="1. 查询从库状态"></a><strong>1. 查询从库状态</strong></h3><p>SHOW SLAVE STATUS\G</p><p>具体指标查看：<a href="##%E5%85%B3%E9%94%AE%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90"><strong>关键字段解析</strong></a></p><h3 id="2-结果发现"><a href="#2-结果发现" class="headerlink" title="2. 结果发现"></a><strong>2. 结果发现</strong></h3><p>Slave_SQL_Running_State 值为： <code>Waiting for table metadata lock</code></p><ul><li>正常值：<code>Reading event from the relay log</code></li></ul><p><strong>Slave_IO_State</strong></p><ul><li>正常值：<code>Waiting for master to send event</code>（等待主库发送事件）</li></ul><p>Slave_IO_Running:</p><ul><li>正常值：<code>Yes</code>（等待主库发送事件）</li></ul><p>发现 Slave_SQL_Running_State 值异常，并没有出现Duplicate column、Unknown、Can’t 、Eorr 等能看出是错误的地方。</p><h3 id="3-针对Waiting-for-table-metadata-lock-排查分析"><a href="#3-针对Waiting-for-table-metadata-lock-排查分析" class="headerlink" title="3. 针对Waiting for table metadata lock 排查分析"></a><strong>3. 针对<code>Waiting for table metadata lock</code> 排查分析</strong></h3><p><strong>可能的原因分析</strong></p><ol><li>主库执行了 DDL 语句<ul><li><code>ALTER TABLE</code>、<code>CREATE INDEX</code>、<code>DROP TABLE</code> 等操作可能会导致锁等待。</li><li>如果从库正在执行 SQL，而主库又修改了表结构，从库可能会等待 metadata lock 释放。</li></ul></li><li>主库长时间未提交事务<ul><li>事务未提交，导致从库 SQL 线程等待执行，阻塞后续操作。</li></ul></li><li>从库上有并发查询占用了表<ul><li>从库上有查询正在使用表，而 <code>SQL_THREAD</code> 需要修改表结构，导致等待。</li></ul></li><li>使用了 <code>LOCK TABLES</code><ul><li>如果主库或者从库有 <code>LOCK TABLES</code>，可能会阻止复制线程获取 metadata lock。</li></ul></li></ol><p>通过现象分析 主库执行DDL 语句但并未阻塞，主库正常访问，而且从库的DDL并未执行，说明DDL语句已经阻塞了，排除1，2可能性，查询并未锁表现象，排除4，最大可能就是3</p><h3 id="4-查询未提交的事务"><a href="#4-查询未提交的事务" class="headerlink" title="4. 查询未提交的事务"></a><strong>4. 查询未提交的事务</strong></h3><p><strong>通show processlist</strong> 查到不少等待锁，但这些锁的时间都比较短 明显是DDL阻塞之后的查询也被阻塞1</p><p><img src="/image.png" alt="image"></p><p>执行以下 SQL 语句，检查 <code>INFORMATION_SCHEMA.INNODB_TRX</code> 表，定位未提交的事务：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    trx_id,</span><br><span class="line">    trx_mysql_thread_id,</span><br><span class="line">    trx_query,</span><br><span class="line">    trx_state,</span><br><span class="line">    trx_wait_started,</span><br><span class="line">    TIMESTAMPDIFF(<span class="keyword">SECOND</span>, trx_wait_started, NOW()) <span class="keyword">AS</span> wait_time_seconds</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line">或</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"> <span class="keyword">FROM</span></span><br><span class="line">     information_schema.INNODB_TRX</span><br><span class="line">     <span class="keyword">WHERE</span> STATE<span class="operator">=</span><span class="string">'ACTIVE'</span>;</span><br></pre></td></tr></tbody></table></figure><p>查询结果显示存在 5 个未提交的事务，其中部分事务已运行超过 8 天，并且执行时间仍在持续增加。</p><h3 id="5-关联-SHOW-PROCESSLIST-进行确认"><a href="#5-关联-SHOW-PROCESSLIST-进行确认" class="headerlink" title="5. 关联 SHOW PROCESSLIST 进行确认"></a><strong>5. 关联 <code>SHOW PROCESSLIST</code> 进行确认</strong></h3><p>通过 <code>trx_mysql_thread_id</code> 关联 <code>SHOW PROCESSLIST</code> 进一步确认事务详情，发现一个 ID 为 <code>19138566</code> 的线程，状态如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Id        User        Host                     db                                               Command      Time      State                     Info</span><br><span class="line">19138566  cbcread     10.60.86.91:60369        ioscar_customersystem_customerbasic              Query        648905    Creating <span class="built_in">sort</span> index       SELECT concat(a.id) AS <span class="string">'案件ID'</span>, a.customer_name AS <span class="string">'客户'</span>,   ac.account_age AS <span class="string">'账龄段'</span>,</span><br></pre></td></tr></tbody></table></figure><p>该查询已运行 <strong>648905 秒（约 8 天）</strong>，且执行时间仍在增长，表明该事务可能已进入死锁或长时间未提交，严重影响 MySQL 性能和主从同步。</p><h3 id="6-终止异常事务"><a href="#6-终止异常事务" class="headerlink" title="6. 终止异常事务"></a><strong>6. 终止异常事务</strong></h3><p>由于该事务占用资源并可能阻塞主从同步，立即执行 <code>KILL</code> 命令终止该事务：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL <span class="number">19138566</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="7-观察从库状态变化"><a href="#7-观察从库状态变化" class="headerlink" title="7. 观察从库状态变化"></a><strong>7. 观察从库状态变化</strong></h3><p>执行 <code>SHOW SLAVE STATUS;</code> 查看主从同步状态，发现 <code>Slave_SQL_Running_State</code> 由 <strong>Waiting for Master to send event</strong> 变更为 <strong>altering table</strong>，说明从库正在执行 <code>ALTER TABLE</code> 语句，即之前被阻塞的 DDL 语句开始恢复执行。</p><p>随着 <code>ALTER TABLE</code> 事件完成，<code>Slave_SQL_Running_State</code> 逐步变更为：</p><ul><li><code>Waiting for Slave Worker queue</code></li><li><code>Reading event from the relay log</code></li></ul><p>此时，说明从库已恢复正常同步，并正在继续处理 relay log。</p><h3 id="8-监控主从延迟恢复情况"><a href="#8-监控主从延迟恢复情况" class="headerlink" title="8. 监控主从延迟恢复情况"></a><strong>8. 监控主从延迟恢复情况</strong></h3><p>查询 <code>SHOW SLAVE STATUS;</code>，关注 <code>Seconds_Behind_Master</code>（主从延迟时间）：</p><ul><li>事务终止前，<code>Seconds_Behind_Master</code> 超过 <strong>9W 秒（约 25 小时）</strong></li><li>终止事务后，<code>Seconds_Behind_Master</code> 开始逐步缩小</li><li>经过数小时观察，主从延迟最终缩小至 <strong>1 秒以内</strong></li><li>验证主从数据，确保数据一致性</li></ul><h3 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a><strong>9. 结论</strong></h3><p>本次 MySQL 主从延迟的根因是 <strong>长期未提交的事务阻塞了主库的 binlog 生成，从而影响从库的同步</strong>。通过以下步骤成功修复问题：</p><ol><li>查询未提交事务，定位长期运行 SQL</li><li>通过 <code>SHOW PROCESSLIST</code> 确认事务状态</li><li><code>KILL</code> 关键阻塞事务</li><li>观察 <code>SHOW SLAVE STATUS</code> 变化，验证 <code>Slave_SQL_Running_State</code> 状态</li><li>监控 <code>Seconds_Behind_Master</code> 缩小至 1 秒，确保主从同步恢复</li></ol><p>至此，主从同步恢复正常，问题解决。</p><h2 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h2><p>后续分析事故产生原理</p><p>主要从是 <a href="##MySQL%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81">MySQL共享锁和独占锁</a> 分析</p><p><strong>发生 <code>Waiting for table metadata lock</code> 的原因</strong></p><p>当 <code>ALTER TABLE</code> 需要 <code>X 锁</code>，但表上有正在执行的 <code>SELECT</code> 时，<code>ALTER TABLE</code> 会<strong>进入等待状态</strong>。这时 <strong>新的查询（SELECT）也会被阻塞</strong>，即使它只是想获取 S 锁！</p><p><strong>📌 详细的锁定过程</strong></p><ol><li><code>SELECT</code> 语句执行，获取 **<code>S 锁</code>**（共享 metadata lock）。</li><li>你运行 <code>ALTER TABLE</code>，它需要 <strong><code>X 锁</code><strong>（独占 metadata lock），所以它必须</strong>等待</strong>所有 <code>S 锁</code> 释放。</li><li><strong><code>ALTER TABLE</code> 在等待时，新来的 <code>SELECT</code> 也会被阻塞！</strong><ul><li>因为 MySQL <strong>会保证所有等待中的事务按顺序执行</strong>。</li><li><code>ALTER TABLE</code> 必须先执行完，新的 <code>SELECT</code> 才能继续。</li></ul></li></ol><h2 id="关键字段解析"><a href="#关键字段解析" class="headerlink" title="关键字段解析"></a><strong>关键字段解析</strong></h2><p><code>SHOW SLAVE STATUS\G</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master to send event --IO thread的状态</span><br><span class="line">                  Master_Host: 10.10.10.10         -- 主库的地址     </span><br><span class="line">                  Master_User: repl                -- 用于连接主库复制账号（这个账号是在主库上创建）</span><br><span class="line">                  Master_Port: 3300                -- 主库的端口</span><br><span class="line">                Connect_Retry: 10                  -- 连接重试之间的秒数（默认 60）</span><br><span class="line">              Master_Log_File: mysql-bin.005395    -- I/O 线程当前正在读取的主库的二进制日志文件名称。</span><br><span class="line">          Read_Master_Log_Pos: 684976832           -- I/O 线程已读取的当前主库二进制日志文件中的位点</span><br><span class="line">               Relay_Log_File: dd-relay.000063     -- SQL线程正在读取和执行的中继日志名称</span><br><span class="line">                Relay_Log_Pos: 684953253           -- SQL线程正在读取和执行的当前中继日志的位点</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.005395    -- SQL 线程执行的最新事件 对应在主库上的二进制日志文件名称。</span><br><span class="line">             Slave_IO_Running: Yes                 -- IO线程是否已启动并已成功连接到主库</span><br><span class="line">            Slave_SQL_Running: Yes                 -- SQL线程是否启动。</span><br><span class="line">              Replicate_Do_DB:                     -- 需要复制的DB</span><br><span class="line">          Replicate_Ignore_DB:                     -- 复制忽略的DB</span><br><span class="line">           Replicate_Do_Table:                     -- 需要复制的表</span><br><span class="line">       Replicate_Ignore_Table:                     -- 复制忽略的表</span><br><span class="line">      Replicate_Wild_Do_Table:                     -- 用于指定需要复制的数据库表，支持通配符（wildcard）的形式</span><br><span class="line">  Replicate_Wild_Ignore_Table:                     -- 用于指定需要忽略（不复制）的数据库表，同样支持通配符的形式。</span><br><span class="line">                   Last_Errno: 0                   -- Last_SQL_Errno的别名</span><br><span class="line">                   Last_Error:                     -- Last_SQL_Error的别名</span><br><span class="line">                 Skip_Counter: 0                   -- 系统变sql_slave_skip_counter 的当前值  （从库跳过的SQL数量）</span><br><span class="line">          Exec_Master_Log_Pos: 684953080           -- SQL线程已经读取和执行过的中继日志 对应在主库二进制日志文件的位点</span><br><span class="line">              Relay_Log_Space: 684977292           -- 所有现有中继日志文件的总大小。</span><br><span class="line">              Until_Condition: None                -- start slave 中制定 <span class="keyword">until</span> 语句</span><br><span class="line">               Until_Log_File:                     -- start slave 中制定 <span class="keyword">until</span> 语句</span><br><span class="line">                Until_Log_Pos: 0                   -- start slave 中制定 <span class="keyword">until</span> 语句</span><br><span class="line">           Master_SSL_Allowed: No                  -- 是否允许与源的 SSL 连接</span><br><span class="line">           Master_SSL_CA_File:                     -- 指定用于验证主服务器证书的证书颁发机构（CA）文件的路径</span><br><span class="line">           Master_SSL_CA_Path:                     -- 指定用于验证主服务器证书的证书颁发机构（CA）路径的路径</span><br><span class="line">              Master_SSL_Cert:                     -- 指定从服务器的 SSL 证书文件的路径</span><br><span class="line">            Master_SSL_Cipher:                     -- 指定在 SSL 通信中使用的密码套件</span><br><span class="line">               Master_SSL_Key:                     -- 指定从服务器的 SSL 私钥文件的路径</span><br><span class="line">        Seconds_Behind_Master: 0                   -- 主从延迟</span><br><span class="line">Master_SSL_Verify_Server_Cert: No                  -- 表示是否验证主服务器的 SSL 证书。</span><br><span class="line">                Last_IO_Errno: 0                   -- 导致IO线程停止的最近一次的错误码，Errno :0 表示表示没有错误</span><br><span class="line">                Last_IO_Error:                     -- 导致IO线程停止的最近的错误信息 。Erro为空表示没有错误</span><br><span class="line">               Last_SQL_Errno: 0                   -- 导致SQL线程停止的最近的错误码。Errno :0 表示没有错误</span><br><span class="line">               Last_SQL_Error:                     -- 导致SQL线程停止的错误信息,Erro为空表示没有错误</span><br><span class="line">  Replicate_Ignore_Server_Ids:                     -- 忽略复制的主库的server_id</span><br><span class="line">             Master_Server_Id: 181323300           -- 主库的参数server_id的值</span><br><span class="line">                  Master_UUID: 127ef593-1826-11eb-8a97-6c92bf7d39de           -- 主库参数server_uuid的值</span><br><span class="line">             Master_Info_File: mysql.slave_master_info                        -- 在从库上存储主库信息的文件或表</span><br><span class="line">                    SQL_Delay: 0                                              -- 从库延迟主库多少秒</span><br><span class="line">          SQL_Remaining_Delay: NULL                                           -- 当Slave_SQL_Running_State为 时 Waiting <span class="keyword">until</span> MASTER_DELAY seconds after master executed event，该字段包含剩余延迟秒数。其他时候，该字段为 NULL。</span><br><span class="line">      Slave_SQL_Running_State: Slave has <span class="built_in">read</span> all relay <span class="built_in">log</span>; waiting <span class="keyword">for</span> more updates -- SQL线程的运行状态</span><br><span class="line">           Master_Retry_Count: 86400  -- 在连接丢失的情况下，从库可以尝试重新连接到主库的次数。</span><br><span class="line">                  Master_Bind:       --</span><br><span class="line">      Last_IO_Error_Timestamp:       -- 最近的I/O 线程发生错误的时间 格式YYMMDD hh:mm:ss</span><br><span class="line">     Last_SQL_Error_Timestamp:       -- 最近的SQL 线程发生错误的时间 格式YYMMDD hh:mm:ss</span><br><span class="line">               Master_SSL_Crl:       -- 指定撤销列表 (CRL) 文件的路径，该文件包含已被撤销的 SSL 证书列表</span><br><span class="line">           Master_SSL_Crlpath:       -- 指定撤销列表 (CRL) 文件的路径，该文件包含已被撤销的 SSL 证书列表</span><br><span class="line">           Retrieved_Gtid_Set: 127ef593-1826-11eb-8a97-6c92bf7d39de:330411-2764671 -- 从库已经接收到的GTID的集合（I/O线程），如果GTID模式没有开启则为空。这个值是现在存在或者已经存在在relay <span class="built_in">log</span>中的GTID集合</span><br><span class="line">            Executed_Gtid_Set: 127ef593-1826-11eb-8a97-6c92bf7d39de:1-2764671,</span><br><span class="line">3133d0b5-8d65-11e7-9f2e-c88d83a9846a:1-12697883,</span><br><span class="line">657b7d6b-8d60-11e7-b85f-6c92bf4e09e6:1-1661102840    -- 已经被写进binlog的GTID的集合（SQL线程），这个值和 系统参数 gtid_executed 相同。也和在该实例上执行 show master status 中的Executed_Gtid_Set 值相同</span><br><span class="line">                Auto_Position: 1  -- 如果正在使用自动定位1；否则为 0。</span><br><span class="line">         Replicate_Rewrite_DB:    -- 用于指定需要在主从复制过程中进行数据库名重写的规则。</span><br><span class="line">                 Channel_Name:    -- 正在显示的复制通道</span><br><span class="line">           Master_TLS_Version:    -- 源上使用的 TLS 版本</span><br></pre></td></tr></tbody></table></figure><p>执行后，可能会看到如下重要字段：</p><ul><li><code>SHOW SLAVE STATUS\G</code> 主要用于监控从库同步状态。</li><li><code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 应该都是 <code>Yes</code>。</li><li><code>Seconds_Behind_Master</code> 应该尽量接近 <code>0</code>。</li><li>如果有错误，可以 <code>STOP SLAVE</code>，检查 <code>Last_Error</code>，必要时重新设置主从关系</li></ul><p><code>Slave_IO_Running</code> 字段用于指示 MySQL 复制中 I/O 线程的运行状态，常见的值包括：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><code>Yes</code></td><td>I/O 线程正在运行，正常从主库读取 binlog</td></tr><tr><td><code>No</code></td><td>I/O 线程未运行，可能由于错误或手动停止</td></tr><tr><td><code>Connecting</code></td><td>I/O 线程正在尝试连接主库，但尚未成功</td></tr></tbody></table><h3 id="常见情况解析"><a href="#常见情况解析" class="headerlink" title="常见情况解析"></a><strong>常见情况解析</strong></h3><ol><li><strong>正常状态</strong><ul><li><code>Slave_IO_Running: Yes</code></li><li>说明从库成功连接到主库，并在持续接收 binlog。</li></ul></li><li><strong>连接失败</strong><ul><li><code>Slave_IO_Running: Connecting</code></li><li>说明从库正在尝试连接主库，但尚未成功，可能是：<ul><li>主库地址 (<code>Master_Host</code>) 配置错误</li><li>主库未开启 <code>binlog</code></li><li>端口 (<code>Master_Port</code>) 未开放</li><li>账户或密码错误 (<code>Master_User</code> / <code>Master_Password</code>)</li></ul></li></ul></li><li><strong>I/O 线程停止</strong><ul><li><code>Slave_IO_Running: No</code></li><li>可能原因：<ul><li>手动执行了 <code>STOP SLAVE</code></li><li>网络问题导致连接断开</li><li>认证失败（账号或权限问题）</li><li><code>Last_IO_Error</code> 字段中可能会有详细错误信息</li></ul></li></ul></li></ol><p><code>Slave_IO_State</code> 是 <code>SHOW SLAVE STATUS\G</code> 输出中的一个字段，它描述了 MySQL 复制中 <strong>I/O 线程当前的状态</strong>，表示它正在执行的操作。</p><h3 id="常见-Slave-IO-State-值及含义"><a href="#常见-Slave-IO-State-值及含义" class="headerlink" title="常见 Slave_IO_State 值及含义"></a><strong>常见 <code>Slave_IO_State</code> 值及含义</strong></h3><table><thead><tr><th><code>Slave_IO_State</code> 值</th><th>说明</th></tr></thead><tbody><tr><td><strong>Waiting for master to send event</strong></td><td>从库已经成功连接主库，并在等待主库发送 binlog（正常状态）。</td></tr><tr><td><strong>Connecting to master</strong></td><td>正在尝试连接主库，但连接尚未建立，可能是主库未启动或网络问题。</td></tr><tr><td><strong>Waiting for the slave SQL thread to free relay log</strong></td><td>SQL 线程执行过慢，I/O 线程等待 SQL 线程处理 relay log。</td></tr><tr><td><strong>Waiting for master update</strong></td><td>说明主库上没有新的 binlog 事件，I/O 线程在等待更新（通常无问题）。</td></tr><tr><td><strong>Reconnecting after a failed binlog dump request</strong></td><td>从库尝试重新连接主库，可能是由于网络问题或主库重启导致连接断开。</td></tr><tr><td><strong>Waiting for master connection</strong></td><td>复制未正常启动，可能 <code>START SLAVE</code> 尚未执行，或者连接参数错误。</td></tr><tr><td><strong>Queueing master event to the relay log</strong></td><td>I/O 线程正在将主库 binlog 事件写入 relay log（正常状态）。</td></tr><tr><td><strong>Waiting to reconnect after a failed master event read</strong></td><td>从库读取主库 binlog 失败，正在等待重连。可能是主库关闭、网络异常等原因。</td></tr><tr><td><strong>Waiting for master to send event (after aborting replication due to an error)</strong></td><td>发生复制错误，导致 I/O 线程终止，可能需要手动修复并重启 <code>START SLAVE</code>。</td></tr></tbody></table><h3 id="title-时光错位：一次MySQL主从同步延迟的排查与优化"><a href="#title-时光错位：一次MySQL主从同步延迟的排查与优化" class="headerlink" title="title: 时光错位：一次MySQL主从同步延迟的排查与优化"></a>title: 时光错位：一次MySQL主从同步延迟的排查与优化</h3><h3 id="title-时光错位：一次MySQL主从同步延迟的排查与优化-1"><a href="#title-时光错位：一次MySQL主从同步延迟的排查与优化-1" class="headerlink" title="title: 时光错位：一次MySQL主从同步延迟的排查与优化"></a>title: 时光错位：一次MySQL主从同步延迟的排查与优化</h3><h3 id="Slave-SQL-Running-State-解析"><a href="#Slave-SQL-Running-State-解析" class="headerlink" title="Slave_SQL_Running_State 解析"></a><strong><code>Slave_SQL_Running_State</code> 解析</strong></h3><p><code>Slave_SQL_Running_State</code> 主要描述 <strong>从库 SQL 线程的当前状态</strong>，可以帮助判断从库是否正常执行 <strong>binlog 事件</strong>。</p><hr><h3 id="📌-常见状态解析"><a href="#📌-常见状态解析" class="headerlink" title="📌 常见状态解析"></a><strong>📌 常见状态解析</strong></h3><p>执行 <code>SHOW SLAVE STATUS\G</code> 可能会看到以下 <code>Slave_SQL_Running_State</code>：</p><table><thead><tr><th>状态</th><th>说明</th><th>解决方案（如果有问题）</th></tr></thead><tbody><tr><td><strong>Reading event from the relay log</strong></td><td>SQL 线程正在从 relay log 读取 binlog 事件，并准备执行</td><td><strong>正常状态</strong>，无需处理</td></tr><tr><td><strong>Waiting for dependent transaction to commit</strong></td><td>等待前一个事务提交（事务串行化导致等待）</td><td><strong>正常状态</strong>，但如果卡住太久，检查 <code>SHOW PROCESSLIST;</code></td></tr><tr><td><strong>Waiting for master to send event</strong></td><td>从库 I/O 线程在等待主库发送 binlog 事件</td><td><strong>正常状态</strong>，但如果长时间无进展，检查 <code>Slave_IO_Running</code></td></tr><tr><td><strong>Slave has read all relay log; waiting for more updates</strong></td><td>从库 SQL 线程已经执行完 relay log，等待新的数据</td><td><strong>正常状态</strong></td></tr><tr><td><strong>Waiting for table metadata lock</strong></td><td>被 <strong>metadata lock</strong> 阻塞，导致 SQL 线程无法继续</td><td>参见 本文 <strong>解决方案</strong></td></tr><tr><td><strong>Waiting for an event from Coordinator</strong></td><td>适用于多线程复制（MTS），SQL 线程在等待事件分配</td><td><strong>正常状态</strong>，但如果卡住，检查 <code>SHOW PROCESSLIST;</code></td></tr><tr><td><strong>Error ‘…’ on query. Default database: ‘…’. Query: ‘…’</strong></td><td>复制 SQL 线程遇到错误，可能导致复制停止</td><td>检查 <code>Last_SQL_Error</code> 并修复错误</td></tr><tr><td><strong>NULL（空值）</strong></td><td>SQL 线程未运行（可能已停止）</td><td><code>START SLAVE SQL_THREAD;</code> 重新启动</td></tr></tbody></table><h2 id="MySQL共享锁和独占锁"><a href="#MySQL共享锁和独占锁" class="headerlink" title="MySQL共享锁和独占锁"></a>MySQL<strong>共享锁</strong>和独占锁</h2><p>在 MySQL 数据库中，锁机制是确保数据一致性和完整性的重要手段，主要分为<strong>共享锁</strong>（Shared Lock，简称 S 锁）和<strong>独占锁</strong>（Exclusive Lock，简称 X 锁）。</p><h3 id="共享锁（S-锁）"><a href="#共享锁（S-锁）" class="headerlink" title="共享锁（S 锁）"></a>共享锁（S 锁）</h3><p>共享锁允许多个事务同时读取同一数据，而不会相互阻塞。当一个事务对数据加上共享锁后，其他事务也可以对该数据加共享锁，但不能加独占锁。这意味着在持有共享锁的情况下，数据只能被读取，不能被修改。</p><p><strong>应用场景：</strong></p><p>当需要读取某条记录并希望防止其他事务对其进行修改时，可以使用共享锁。在 MySQL 中，可以通过在 <code>SELECT</code> 语句后添加 <code>LOCK IN SHARE MODE</code> 来实现：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- 其他操作</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></tbody></table></figure><p>上述语句会对 <code>your_table</code> 中满足条件的记录加上共享锁，直到事务提交或回滚后释放。</p><h3 id="独占锁（X-锁）"><a href="#独占锁（X-锁）" class="headerlink" title="独占锁（X 锁）"></a>独占锁（X 锁）</h3><p>独占锁又称为排他锁或写锁，在同一时刻只允许一个事务对数据进行修改。当一个事务对数据加上独占锁后，其他事务既不能加共享锁，也不能加独占锁，必须等待锁的释放。这确保了数据的修改操作是互斥的，防止了并发修改导致的数据不一致问题。</p><p><strong>应用场景：</strong></p><p>当需要更新或删除某条记录，并希望在操作完成前防止其他事务对其进行读取或修改时，可以使用独占锁。在 MySQL 中，<code>UPDATE</code>、<code>DELETE</code> 等操作会自动对涉及的记录加独占锁。如果需要在 <code>SELECT</code> 查询时手动加独占锁，可以使用 <code>FOR UPDATE</code>：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></tbody></table></figure><p>上述语句会对 <code>your_table</code> 中满足条件的记录加上独占锁，直到事务提交或回滚后释放。</p><h3 id="共享锁与独占锁的兼容性"><a href="#共享锁与独占锁的兼容性" class="headerlink" title="共享锁与独占锁的兼容性"></a>共享锁与独占锁的兼容性</h3><p>共享锁和独占锁之间的兼容性如下：</p><ul><li><strong>共享锁 vs. 共享锁</strong>：兼容，多个事务可以同时持有共享锁。</li><li><strong>共享锁 vs. 独占锁</strong>：不兼容，若一个事务持有共享锁，其他事务不能获取独占锁，反之亦然。</li><li><strong>独占锁 vs. 独占锁</strong>：不兼容，一个事务持有独占锁时，其他事务不能获取独占锁。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>默认读取行为</strong>：在 MySQL 的 InnoDB 存储引擎中，普通的 <code>SELECT</code> 语句默认使用<strong>快照读</strong>，不会加任何锁，而是通过多版本并发控制（MVCC）机制读取数据的快照。只有在显式使用 <code>LOCK IN SHARE MODE</code> 或 <code>FOR UPDATE</code> 时，才会对读取的数据加锁。</li><li><strong>死锁与性能</strong>：过度使用锁可能导致死锁或性能下降，因此应根据具体需求合理使用锁机制，避免不必要的锁争用。</li></ul><p>通过正确理解和使用共享锁与独占锁，可以有效控制并发事务对数据的访问，确保数据的正确性和一致性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;时光错位：一次MySQL主从同步延迟的排查与优化&quot;&gt;&lt;a href=&quot;#时光错位：一次MySQL主从同步延迟的排查与优化&quot; class=&quot;headerlink&quot; title=&quot;时光错位：一次MySQL主从同步延迟的排查与优化&quot;&gt;&lt;/a&gt;时光错位：一次MySQL主从</summary>
      
    
    
    
    <category term="MySQL" scheme="https://blog.restlessnight.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.restlessnight.cn/tags/MySQL/"/>
    
    <category term="主从同步" scheme="https://blog.restlessnight.cn/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.restlessnight.cn/2025/04/03/hello-world/"/>
    <id>https://blog.restlessnight.cn/2025/04/03/hello-world/</id>
    <published>2025-04-03T08:53:27.389Z</published>
    <updated>2025-04-07T06:13:00.555Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="hello" scheme="https://blog.restlessnight.cn/categories/hello/"/>
    
    
  </entry>
  
</feed>
